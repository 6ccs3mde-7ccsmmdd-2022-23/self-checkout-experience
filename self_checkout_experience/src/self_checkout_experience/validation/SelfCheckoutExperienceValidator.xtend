/*
 * generated by Xtext 2.25.0
 */
package self_checkout_experience.validation
import org.eclipse.xtext.validation.Check
import self_checkout_experience.selfCheckoutExperience.VariableDeclaration
import self_checkout_experience.selfCheckoutExperience.SelfCheckoutExperiencePackage
import self_checkout_experience.selfCheckoutExperience.ItemDef
import java.util.List
import self_checkout_experience.selfCheckoutExperience.Repeat
import self_checkout_experience.selfCheckoutExperience.SelfCheckoutInstore
import self_checkout_experience.selfCheckoutExperience.WalkStatement
import self_checkout_experience.selfCheckoutExperience.HoldBasketStatement
import self_checkout_experience.selfCheckoutExperience.GripState
import self_checkout_experience.selfCheckoutExperience.PickStatement

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class SelfCheckoutExperienceValidator extends AbstractSelfCheckoutExperienceValidator {
	
	public static val INVALID_VARIABLE_NAME = 'self_checkout_experience.selfCheckoutExperience.INVALID_VARIABLE_NAME'
	public static val INVALID_ITEM_NAME = 'self_checkout_experience.selfCheckoutExperience.INVALID_ITEM_NAME'
	public static val INVALID_ITEM_BOUGHT = 'self_checkout_experience.selfCheckoutExperience.INVALID_ITEM_BOUGHT'
	public static val INVALID_BASKET_GRIP = 'self_checkout_experience.selfCheckoutExperience.INVALID_BASKET_GRIP'
	public static val INVALID_HOLDING_ITEM_ACTION = 'self_checkout_experience.selfCheckoutExperience.INVALID_HOLDING_ITEM_ACTION'
	

	// Validation check for variable declarations to start with lower case
	@Check
	def checkVariableNamesStartWithLowerCase(VariableDeclaration decl) {
		if (!Character.isLowerCase(decl.name.charAt(0))) {
			warning('Name should start with a lower-case character', decl,
				SelfCheckoutExperiencePackage.Literals.VARIABLE_DECLARATION__NAME, INVALID_VARIABLE_NAME)
		}
	}
	
	// Validation check for items to start with upper case
	@Check
	def checkItemsStartWithUpperCase(ItemDef item) {
		if (!Character.isUpperCase(item.name.charAt(0))) {
			warning('Item should start with a upper-case character', item,
				SelfCheckoutExperiencePackage.Literals.ITEM_DEF__NAME, INVALID_ITEM_NAME)
		}
	}
	
	// Validation check for items sold in shop
	@Check(NORMAL)
	def checkNotSoldItemsAtSelfCheckout(ItemDef item) {
		var List<String> notSoldItemsList = newArrayList
		
		notSoldItemsList.add("car")
		notSoldItemsList.add("house")
		notSoldItemsList.add("plane")
		notSoldItemsList.add("human")
		notSoldItemsList.add("university")	
		notSoldItemsList.add("grade")
		notSoldItemsList.add("wall")
		notSoldItemsList.add("homework")		
				
		if (notSoldItemsList.contains(item.name.toString.toLowerCase)){
			warning('Item is not purchasable at self checkout!', item,
				SelfCheckoutExperiencePackage.Literals.ITEM_DEF__NAME, INVALID_ITEM_BOUGHT)	
		}
	}
	
	// Validate a holding item is dropped or added to basket
	@Check
	def checkAddToBasketOrDropComesAfterPick(PickStatement pickStmn){
		if(pickStmn.holdingItem === null){
			warning('Drop or add to basket item', pickStmn,
				SelfCheckoutExperiencePackage.Literals.PICK_STATEMENT__HOLDING_ITEM, 
				INVALID_HOLDING_ITEM_ACTION)
		}		
	}
	
	// Validate that basket is in hand before they pay
	@Check(NORMAL)
	def checkAlwaysHaveBasketGrip(SelfCheckoutInstore program) {
		
		val walking = program.statement.filter(WalkStatement).toList
 		if (!(walking.checkAlwaysHaveBasketGrip(true))) {
			val listOfHolding = walking.filter(HoldBasketStatement)
			val lastHolding = listOfHolding.get(listOfHolding.size()-1)

			warning('This program cannot end with the basket on floor', lastHolding,
				SelfCheckoutExperiencePackage.Literals.HOLD_BASKET_STATEMENT__STATE, INVALID_BASKET_GRIP)
		}
	}

	def boolean checkAlwaysHaveBasketGrip(List<WalkStatement> statements, boolean startState) {
		statements.fold(startState, [ previousState, stmt |
			stmt.predictBasketGrip(previousState)
		])
	}
	
	dispatch def predictBasketGrip(WalkStatement stmt, boolean previousState) { previousState }

	dispatch def predictBasketGrip(HoldBasketStatement stmt, boolean previousState) { 
				stmt.state === GripState.GRIP
	}
	
	dispatch def predictBasketGrip(Repeat stmt, boolean previousState) {
		val walking = stmt.statement.filter(WalkStatement).toList
		walking.checkAlwaysHaveBasketGrip(previousState)
	}
	
}
