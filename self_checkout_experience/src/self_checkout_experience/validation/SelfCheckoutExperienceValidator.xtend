/*
 * generated by Xtext 2.25.0
 */
package self_checkout_experience.validation
import org.eclipse.xtext.validation.Check
import self_checkout_experience.selfCheckoutExperience.VariableDeclaration
import self_checkout_experience.selfCheckoutExperience.SelfCheckoutExperiencePackage
import self_checkout_experience.selfCheckoutExperience.ItemDef
import java.util.List
import self_checkout_experience.selfCheckoutExperience.Self_checkout
import org.eclipse.emf.common.util.EList
import self_checkout_experience.selfCheckoutExperience.SelfCheckoutExperience
import self_checkout_experience.selfCheckoutExperience.Repeat
import self_checkout_experience.selfCheckoutExperience.SelfCheckoutInstore
import self_checkout_experience.selfCheckoutExperience.WalkStatement
import self_checkout_experience.selfCheckoutExperience.HoldBasketStatement
import self_checkout_experience.selfCheckoutExperience.GripState
import org.eclipse.emf.ecore.util.EcoreUtil
import self_checkout_experience.selfCheckoutExperience.PickStatement

//////REQUIRED: ONE SYNTAX, STATIC SEMATNICS, DYNAMIC SEMANTICS 

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class SelfCheckoutExperienceValidator extends AbstractSelfCheckoutExperienceValidator {
	

	public static val INVALID_VARIABLE_NAME = 'self_checkout_experience.selfCheckoutExperience.INVALID_VARIABLE_NAME'
	public static val INVALID_ITEM_NAME = 'self_checkout_experience.selfCheckoutExperience.INVALID_ITEM_NAME'
	public static val INVALID_ITEM_PLURAL = 'self_checkout_experience.selfCheckoutExperience.INVALID_ITEM_PLURAL'	
	public static val INVALID_ITEM_BOUGHT = 'self_checkout_experience.selfCheckoutExperience.INVALID_ITEM_BOUGHT'
	public static val MAY_NOT_BASKET_UP = 'self_checkout_experience.selfCheckoutExperience.MAY_NOT_BASKET_UP'
	public static val INVALID_HOLDING_ITEM_ACTION = 'self_checkout_experience.selfCheckoutExperience.INVALID_HOLDING_ITEM_ACTION'
	

	// Validation check for variable declarations to start with lower case
	@Check
	def checkVariableNamesStartWithLowerCase(VariableDeclaration decl) {
		if (!Character.isLowerCase(decl.name.charAt(0))) {
			warning('Name should start with a lower-case character', decl,
				SelfCheckoutExperiencePackage.Literals.VARIABLE_DECLARATION__NAME, INVALID_VARIABLE_NAME)
		}
	}
	
	// Validation check for items to start with upper case
	@Check
	def checkItemsStartWithUpperCase(ItemDef item) {
		if (!Character.isUpperCase(item.name.charAt(0))) {
			warning('Item should start with a upper-case character', item,
				SelfCheckoutExperiencePackage.Literals.ITEM_DEF__NAME, INVALID_ITEM_NAME)
		}
	}
	
	// Validation check for items sold in shop
	@Check(NORMAL)
	def checkNotSoldItemsAtSelfCheckout(ItemDef item) {
		var List<String> notSoldItemsList = newArrayList
		
		notSoldItemsList.add("car")
		notSoldItemsList.add("house")
		notSoldItemsList.add("plane")
		notSoldItemsList.add("human")
		notSoldItemsList.add("university")	
		notSoldItemsList.add("grade")
		notSoldItemsList.add("wall")
		notSoldItemsList.add("homework")		
				
		if (notSoldItemsList.contains(item.name.toString.toLowerCase)){
			warning('Item is not purchasable at self checkout!', item,
				SelfCheckoutExperiencePackage.Literals.ITEM_DEF__NAME, INVALID_ITEM_BOUGHT)	
		}
	}
	
	@Check
	def checkAddToBasketOrDropComesAfterPick(PickStatement pickStmn){
		if(pickStmn.holdingItem === null){
			warning('Holding item needs assignment', pickStmn,
				SelfCheckoutExperiencePackage.Literals.PICK_STATEMENT__HOLDING_ITEM, 
				INVALID_HOLDING_ITEM_ACTION)
		}
		
	}
	
	
	
	
	
	
	
	
	
}

//////////////////////////////ASK STEFFEN///////////////////////////////////
//	// Validate that basket is up before they pay
//	@Check(NORMAL)
//	def checkAlwaysHaveBasketUp(SelfCheckoutInstore program) {
//		
//		val walking = program.statement.filter(WalkStatement).toList
//		val eList = EcoreUtil.copyAll(walking) as EList<WalkStatement>
//
////		if (!(walking.checkAlwaysHavePenDown(true))) {
//		if (!(eList.checkAlwaysHaveBasketUp(true))) {
//			warning('This program may not end with the basket down', program,
//				SelfCheckoutExperiencePackage.Literals.SELF_CHECKOUT_INSTORE__STATEMENT, MAY_NOT_BASKET_UP )
//		}
//	}
//
//	def boolean checkAlwaysHaveBasketUp(EList<WalkStatement> statements, boolean startState) {
//		statements.fold(startState, [ previousState, stmt |
//			stmt.predictBasketGripOutcome(previousState)
//		])
//	}
//	
//	dispatch def predictBasketGripOutcome(WalkStatement stmt, boolean previousState) { previousState }
//
//	dispatch def predictBasketGripOutcome(HoldBasketStatement stmt, boolean previousState) { 
//				println(stmt.state)
//				stmt.state === GripState.UP
//	}
//
//	dispatch def predictBasketGripOutcome(Repeat stmt, boolean previousState) {
//		val walking = stmt.statement.filter(WalkStatement).toList
//		val eList = EcoreUtil.copyAll(walking) as EList<WalkStatement>
//		eList.checkAlwaysHaveBasketUp(previousState)
//	}
////	set pay to fasle
//// then check at every statement that pay is true -> warning to say maek sure to pay
//// set to true if pay cmnd is used
//}
