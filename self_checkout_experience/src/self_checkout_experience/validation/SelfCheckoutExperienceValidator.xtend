/*
 * generated by Xtext 2.25.0
 */
package self_checkout_experience.validation
import org.eclipse.xtext.validation.Check
import self_checkout_experience.selfCheckoutExperience.VariableDeclaration
import self_checkout_experience.selfCheckoutExperience.SelfCheckoutExperiencePackage
import self_checkout_experience.selfCheckoutExperience.ItemDef
import java.util.List
import self_checkout_experience.selfCheckoutExperience.Self_checkout
import org.eclipse.emf.common.util.EList
import self_checkout_experience.selfCheckoutExperience.SelfCheckoutExperience
import self_checkout_experience.selfCheckoutExperience.Repeat
import self_checkout_experience.selfCheckoutExperience.SelfCheckoutInstore
import self_checkout_experience.selfCheckoutExperience.WalkStatement
import self_checkout_experience.selfCheckoutExperience.HoldBasketStatement
import self_checkout_experience.selfCheckoutExperience.GripState
import org.eclipse.emf.ecore.util.EcoreUtil

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class SelfCheckoutExperienceValidator extends AbstractSelfCheckoutExperienceValidator {
	

	public static val INVALID_VARIABLE_NAME = 'uk.ac.kcl.inf.szschaler.turtles.INVALID_VARIABLE_NAME'
	public static val INVALID_ITEM_NAME = 'uk.ac.kcl.inf.szschaler.turtles.INVALID_ITEM_NAME'
	public static val INVALID_ITEM_PLURAL = 'uk.ac.kcl.inf.szschaler.turtles.INVALID_ITEM_PLURAL'	
	public static val INVALID_ITEM_BOUGHT = 'uk.ac.kcl.inf.szschaler.turtles.INVALID_ITEM_BOUGHT'
	public static val MAY_NOT_BASKET_UP = 'uk.ac.kcl.inf.szschaler.turtles.MAY_NOT_BASKET_UP'
	
	

	// Validation check for variable declarations to start with lower case
	@Check
	def checkVariableNamesStartWithLowerCase(VariableDeclaration decl) {
		if (!Character.isLowerCase(decl.name.charAt(0))) {
			warning('Name should start with a lower-case character', decl,
				SelfCheckoutExperiencePackage.Literals.VARIABLE_DECLARATION__NAME, INVALID_VARIABLE_NAME)
		}
	}
	
	// Validation check for items to start with upper case
	@Check
	def checkItemsStartWithUpperCase(ItemDef item) {
		if (!Character.isUpperCase(item.name.charAt(0))) {
			warning('Item should start with a upper-case character', item,
				SelfCheckoutExperiencePackage.Literals.ITEM_DEF__NAME, INVALID_ITEM_NAME)
		}
	}
	

	
	// Validation check for items sold in shop
	@Check
	def checkNotSoldItemsAtSelfCheckout(ItemDef item) {
		var List<String> notSoldItemsList = newArrayList
		
		notSoldItemsList.add("car")
		notSoldItemsList.add("house")
		notSoldItemsList.add("plane")
		notSoldItemsList.add("human")
		notSoldItemsList.add("university")	
		notSoldItemsList.add("grade")
		notSoldItemsList.add("wall")
		notSoldItemsList.add("homework")		
		notSoldItemsList.add("cars")
		notSoldItemsList.add("houses")
		notSoldItemsList.add("planes")
		notSoldItemsList.add("humans")
		notSoldItemsList.add("universities")	
		notSoldItemsList.add("grades")
		notSoldItemsList.add("walls")	
		notSoldItemsList.add("homeworks")
				
		if (notSoldItemsList.contains(item.name.toString.toLowerCase)){
			warning('Item is not purchasable at self checkout!', item,
				SelfCheckoutExperiencePackage.Literals.ITEM_DEF__NAME, INVALID_ITEM_BOUGHT)	
		}
	}

//////////////////////////////ASK STEFFEN///////////////////////////////////
//	// Validate that basket is up before they pay
//	@Check(NORMAL)
//	def checkAlwaysHaveBasketUp(SelfCheckoutInstore program) {
//		
//		val walking = program.statement.filter(WalkStatement).toList
//		val eList = EcoreUtil.copyAll(walking) as EList<WalkStatement>
//
////		if (!(walking.checkAlwaysHavePenDown(true))) {
//		if (!(eList.checkAlwaysHaveBasketUp(true))) {
//			warning('This program may not end with the basket down', program,
//				SelfCheckoutExperiencePackage.Literals.SELF_CHECKOUT_INSTORE__STATEMENT, MAY_NOT_BASKET_UP )
//		}
//	}
//
//	def boolean checkAlwaysHaveBasketUp(EList<WalkStatement> statements, boolean startState) {
//		statements.fold(startState, [ previousState, stmt |
//			stmt.predictBasketGripOutcome(previousState)
//		])
//	}
//	
//	dispatch def predictBasketGripOutcome(WalkStatement stmt, boolean previousState) { previousState }
//
//	dispatch def predictBasketGripOutcome(HoldBasketStatement stmt, boolean previousState) { 
//				println(stmt.state)
//				stmt.state === GripState.UP
//	}
//
//	dispatch def predictBasketGripOutcome(Repeat stmt, boolean previousState) {
//		stmt.statement.checkAlwaysHaveBasketUp(previousState)
//	}
	
	
}
