/**
 * generated by Xtext 2.25.0
 */
package self_checkout_experience.validation;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import java.util.Arrays;
import java.util.List;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Functions.Function2;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import self_checkout_experience.selfCheckoutExperience.GripState;
import self_checkout_experience.selfCheckoutExperience.HoldBasketStatement;
import self_checkout_experience.selfCheckoutExperience.ItemDef;
import self_checkout_experience.selfCheckoutExperience.PickStatement;
import self_checkout_experience.selfCheckoutExperience.Repeat;
import self_checkout_experience.selfCheckoutExperience.SelfCheckoutExperiencePackage;
import self_checkout_experience.selfCheckoutExperience.SelfCheckoutInstore;
import self_checkout_experience.selfCheckoutExperience.VariableDeclaration;
import self_checkout_experience.selfCheckoutExperience.WalkStatement;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class SelfCheckoutExperienceValidator extends AbstractSelfCheckoutExperienceValidator {
  private enum PredictedBasketState {
    GRIP,
    
    RELEASE,
    
    UNDETERMINED;
  }
  
  public static final String INVALID_VARIABLE_NAME = "self_checkout_experience.selfCheckoutExperience.INVALID_VARIABLE_NAME";
  
  public static final String INVALID_ITEM_NAME = "self_checkout_experience.selfCheckoutExperience.INVALID_ITEM_NAME";
  
  public static final String INVALID_ITEM_BOUGHT = "self_checkout_experience.selfCheckoutExperience.INVALID_ITEM_BOUGHT";
  
  public static final String INVALID_BASKET_GRIP = "self_checkout_experience.selfCheckoutExperience.INVALID_BASKET_GRIP";
  
  public static final String INVALID_HOLDING_ITEM_ACTION = "self_checkout_experience.selfCheckoutExperience.INVALID_HOLDING_ITEM_ACTION";
  
  @Check
  public void checkVariableNamesStartWithLowerCase(final VariableDeclaration decl) {
    boolean _isLowerCase = Character.isLowerCase(decl.getName().charAt(0));
    boolean _not = (!_isLowerCase);
    if (_not) {
      this.warning("Name should start with a lower-case character", decl, 
        SelfCheckoutExperiencePackage.Literals.VARIABLE_DECLARATION__NAME, SelfCheckoutExperienceValidator.INVALID_VARIABLE_NAME);
    }
  }
  
  @Check
  public void checkItemsStartWithUpperCase(final ItemDef item) {
    boolean _isUpperCase = Character.isUpperCase(item.getName().charAt(0));
    boolean _not = (!_isUpperCase);
    if (_not) {
      this.warning("Item should start with a upper-case character", item, 
        SelfCheckoutExperiencePackage.Literals.ITEM_DEF__NAME, SelfCheckoutExperienceValidator.INVALID_ITEM_NAME);
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkNotSoldItemsAtSelfCheckout(final ItemDef item) {
    List<String> notSoldItemsList = CollectionLiterals.<String>newArrayList();
    notSoldItemsList.add("car");
    notSoldItemsList.add("house");
    notSoldItemsList.add("plane");
    notSoldItemsList.add("human");
    notSoldItemsList.add("university");
    notSoldItemsList.add("grade");
    notSoldItemsList.add("wall");
    notSoldItemsList.add("homework");
    boolean _contains = notSoldItemsList.contains(item.getName().toString().toLowerCase());
    if (_contains) {
      this.warning("Item is not purchasable at self checkout!", item, 
        SelfCheckoutExperiencePackage.Literals.ITEM_DEF__NAME, SelfCheckoutExperienceValidator.INVALID_ITEM_BOUGHT);
    }
  }
  
  @Check
  public void checkAddToBasketOrDropComesAfterPick(final PickStatement pickStmn) {
    EObject _holdingItem = pickStmn.getHoldingItem();
    boolean _tripleEquals = (_holdingItem == null);
    if (_tripleEquals) {
      this.warning("Drop or add to basket item", pickStmn, 
        SelfCheckoutExperiencePackage.Literals.PICK_STATEMENT__HOLDING_ITEM, 
        SelfCheckoutExperienceValidator.INVALID_HOLDING_ITEM_ACTION);
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkAlwaysHaveBasketGrip(final SelfCheckoutInstore program) {
    final List<WalkStatement> walking = IterableExtensions.<WalkStatement>toList(Iterables.<WalkStatement>filter(program.getStatement(), WalkStatement.class));
    SelfCheckoutExperienceValidator.PredictedBasketState _checkAlwaysHaveBasketGrip = this.checkAlwaysHaveBasketGrip(walking, SelfCheckoutExperienceValidator.PredictedBasketState.GRIP);
    boolean _notEquals = (!Objects.equal(_checkAlwaysHaveBasketGrip, SelfCheckoutExperienceValidator.PredictedBasketState.GRIP));
    if (_notEquals) {
      final Iterable<HoldBasketStatement> listOfHolding = Iterables.<HoldBasketStatement>filter(walking, HoldBasketStatement.class);
      int _size = IterableExtensions.size(listOfHolding);
      int _minus = (_size - 1);
      final HoldBasketStatement lastHolding = ((HoldBasketStatement[])Conversions.unwrapArray(listOfHolding, HoldBasketStatement.class))[_minus];
      this.warning("This program cannot end with the basket on floor", lastHolding, 
        SelfCheckoutExperiencePackage.Literals.HOLD_BASKET_STATEMENT__STATE, SelfCheckoutExperienceValidator.INVALID_BASKET_GRIP);
    }
  }
  
  public SelfCheckoutExperienceValidator.PredictedBasketState checkAlwaysHaveBasketGrip(final List<WalkStatement> statements, final SelfCheckoutExperienceValidator.PredictedBasketState startState) {
    final Function2<SelfCheckoutExperienceValidator.PredictedBasketState, WalkStatement, SelfCheckoutExperienceValidator.PredictedBasketState> _function = (SelfCheckoutExperienceValidator.PredictedBasketState previousState, WalkStatement stmt) -> {
      return this.predictBasketGrip(stmt, previousState);
    };
    return IterableExtensions.<WalkStatement, SelfCheckoutExperienceValidator.PredictedBasketState>fold(statements, startState, _function);
  }
  
  protected SelfCheckoutExperienceValidator.PredictedBasketState _predictBasketGrip(final WalkStatement stmt, final SelfCheckoutExperienceValidator.PredictedBasketState previousState) {
    return previousState;
  }
  
  protected SelfCheckoutExperienceValidator.PredictedBasketState _predictBasketGrip(final HoldBasketStatement stmt, final SelfCheckoutExperienceValidator.PredictedBasketState previousState) {
    SelfCheckoutExperienceValidator.PredictedBasketState _xifexpression = null;
    GripState _state = stmt.getState();
    boolean _tripleEquals = (_state == GripState.GRIP);
    if (_tripleEquals) {
      _xifexpression = SelfCheckoutExperienceValidator.PredictedBasketState.GRIP;
    } else {
      _xifexpression = SelfCheckoutExperienceValidator.PredictedBasketState.RELEASE;
    }
    return _xifexpression;
  }
  
  protected SelfCheckoutExperienceValidator.PredictedBasketState _predictBasketGrip(final Repeat stmt, final SelfCheckoutExperienceValidator.PredictedBasketState previousState) {
    SelfCheckoutExperienceValidator.PredictedBasketState _xblockexpression = null;
    {
      final List<WalkStatement> walking = IterableExtensions.<WalkStatement>toList(Iterables.<WalkStatement>filter(stmt.getStatement(), WalkStatement.class));
      final SelfCheckoutExperienceValidator.PredictedBasketState end = this.checkAlwaysHaveBasketGrip(walking, previousState);
      SelfCheckoutExperienceValidator.PredictedBasketState _xifexpression = null;
      if ((end == previousState)) {
        _xifexpression = previousState;
      } else {
        _xifexpression = SelfCheckoutExperienceValidator.PredictedBasketState.UNDETERMINED;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  public SelfCheckoutExperienceValidator.PredictedBasketState predictBasketGrip(final WalkStatement stmt, final SelfCheckoutExperienceValidator.PredictedBasketState previousState) {
    if (stmt instanceof HoldBasketStatement) {
      return _predictBasketGrip((HoldBasketStatement)stmt, previousState);
    } else if (stmt instanceof Repeat) {
      return _predictBasketGrip((Repeat)stmt, previousState);
    } else if (stmt != null) {
      return _predictBasketGrip(stmt, previousState);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(stmt, previousState).toString());
    }
  }
}
