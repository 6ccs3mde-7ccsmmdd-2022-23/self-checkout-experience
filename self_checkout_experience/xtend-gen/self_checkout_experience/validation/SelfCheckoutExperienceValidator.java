/**
 * generated by Xtext 2.25.0
 */
package self_checkout_experience.validation;

import com.google.common.collect.Iterables;
import java.util.Arrays;
import java.util.List;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Functions.Function2;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import self_checkout_experience.selfCheckoutExperience.GripState;
import self_checkout_experience.selfCheckoutExperience.HoldBasketStatement;
import self_checkout_experience.selfCheckoutExperience.ItemDef;
import self_checkout_experience.selfCheckoutExperience.PickStatement;
import self_checkout_experience.selfCheckoutExperience.Repeat;
import self_checkout_experience.selfCheckoutExperience.SelfCheckoutExperiencePackage;
import self_checkout_experience.selfCheckoutExperience.SelfCheckoutInstore;
import self_checkout_experience.selfCheckoutExperience.VariableDeclaration;
import self_checkout_experience.selfCheckoutExperience.WalkStatement;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class SelfCheckoutExperienceValidator extends AbstractSelfCheckoutExperienceValidator {
  public static final String INVALID_VARIABLE_NAME = "self_checkout_experience.selfCheckoutExperience.INVALID_VARIABLE_NAME";
  
  public static final String INVALID_ITEM_NAME = "self_checkout_experience.selfCheckoutExperience.INVALID_ITEM_NAME";
  
  public static final String INVALID_ITEM_PLURAL = "self_checkout_experience.selfCheckoutExperience.INVALID_ITEM_PLURAL";
  
  public static final String INVALID_ITEM_BOUGHT = "self_checkout_experience.selfCheckoutExperience.INVALID_ITEM_BOUGHT";
  
  public static final String INVALID_BASKET_GRIP = "self_checkout_experience.selfCheckoutExperience.INVALID_BASKET_GRIP";
  
  public static final String INVALID_HOLDING_ITEM_ACTION = "self_checkout_experience.selfCheckoutExperience.INVALID_HOLDING_ITEM_ACTION";
  
  @Check
  public void checkVariableNamesStartWithLowerCase(final VariableDeclaration decl) {
    boolean _isLowerCase = Character.isLowerCase(decl.getName().charAt(0));
    boolean _not = (!_isLowerCase);
    if (_not) {
      this.warning("Name should start with a lower-case character", decl, 
        SelfCheckoutExperiencePackage.Literals.VARIABLE_DECLARATION__NAME, SelfCheckoutExperienceValidator.INVALID_VARIABLE_NAME);
    }
  }
  
  @Check
  public void checkItemsStartWithUpperCase(final ItemDef item) {
    boolean _isUpperCase = Character.isUpperCase(item.getName().charAt(0));
    boolean _not = (!_isUpperCase);
    if (_not) {
      this.warning("Item should start with a upper-case character", item, 
        SelfCheckoutExperiencePackage.Literals.ITEM_DEF__NAME, SelfCheckoutExperienceValidator.INVALID_ITEM_NAME);
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkNotSoldItemsAtSelfCheckout(final ItemDef item) {
    List<String> notSoldItemsList = CollectionLiterals.<String>newArrayList();
    notSoldItemsList.add("car");
    notSoldItemsList.add("house");
    notSoldItemsList.add("plane");
    notSoldItemsList.add("human");
    notSoldItemsList.add("university");
    notSoldItemsList.add("grade");
    notSoldItemsList.add("wall");
    notSoldItemsList.add("homework");
    boolean _contains = notSoldItemsList.contains(item.getName().toString().toLowerCase());
    if (_contains) {
      this.warning("Item is not purchasable at self checkout!", item, 
        SelfCheckoutExperiencePackage.Literals.ITEM_DEF__NAME, SelfCheckoutExperienceValidator.INVALID_ITEM_BOUGHT);
    }
  }
  
  @Check
  public void checkAddToBasketOrDropComesAfterPick(final PickStatement pickStmn) {
    EObject _holdingItem = pickStmn.getHoldingItem();
    boolean _tripleEquals = (_holdingItem == null);
    if (_tripleEquals) {
      this.warning("Holding item needs assignment", pickStmn, 
        SelfCheckoutExperiencePackage.Literals.PICK_STATEMENT__HOLDING_ITEM, 
        SelfCheckoutExperienceValidator.INVALID_HOLDING_ITEM_ACTION);
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkAlwaysHaveBasketGrip(final SelfCheckoutInstore program) {
    final List<WalkStatement> walking = IterableExtensions.<WalkStatement>toList(Iterables.<WalkStatement>filter(program.getStatement(), WalkStatement.class));
    InputOutput.<List<WalkStatement>>println(walking);
    boolean _checkAlwaysHaveBasketGrip = this.checkAlwaysHaveBasketGrip(walking, true);
    boolean _not = (!_checkAlwaysHaveBasketGrip);
    if (_not) {
      final Iterable<HoldBasketStatement> listOfHolding = Iterables.<HoldBasketStatement>filter(walking, HoldBasketStatement.class);
      int _size = IterableExtensions.size(listOfHolding);
      int _minus = (_size - 1);
      final HoldBasketStatement lastHolding = ((HoldBasketStatement[])Conversions.unwrapArray(listOfHolding, HoldBasketStatement.class))[_minus];
      InputOutput.<String>println(("HOLDING LIST  " + listOfHolding));
      InputOutput.<String>println(("LAST HOLDING   " + lastHolding));
      InputOutput.<String>println(("prog  " + program));
      this.warning("This program cannot end with the basket on floor", lastHolding, 
        SelfCheckoutExperiencePackage.Literals.HOLD_BASKET_STATEMENT__STATE, SelfCheckoutExperienceValidator.INVALID_BASKET_GRIP);
    }
  }
  
  public boolean checkAlwaysHaveBasketGrip(final List<WalkStatement> statements, final boolean startState) {
    final Function2<Boolean, WalkStatement, Boolean> _function = (Boolean previousState, WalkStatement stmt) -> {
      boolean _xblockexpression = false;
      {
        InputOutput.<String>println(("StartState" + Boolean.valueOf(startState)));
        InputOutput.<String>println(("previous State" + previousState));
        InputOutput.<String>println(("stmt" + stmt));
        _xblockexpression = this.predictBasketGrip(stmt, (previousState).booleanValue());
      }
      return Boolean.valueOf(_xblockexpression);
    };
    return (boolean) IterableExtensions.<WalkStatement, Boolean>fold(statements, Boolean.valueOf(startState), _function);
  }
  
  protected boolean _predictBasketGrip(final WalkStatement stmt, final boolean previousState) {
    return previousState;
  }
  
  protected boolean _predictBasketGrip(final HoldBasketStatement stmt, final boolean previousState) {
    boolean _xblockexpression = false;
    {
      InputOutput.<GripState>println(stmt.getState());
      GripState _state = stmt.getState();
      _xblockexpression = (_state == GripState.GRIP);
    }
    return _xblockexpression;
  }
  
  protected boolean _predictBasketGrip(final Repeat stmt, final boolean previousState) {
    boolean _xblockexpression = false;
    {
      final List<WalkStatement> walking = IterableExtensions.<WalkStatement>toList(Iterables.<WalkStatement>filter(stmt.getStatement(), WalkStatement.class));
      _xblockexpression = this.checkAlwaysHaveBasketGrip(walking, previousState);
    }
    return _xblockexpression;
  }
  
  public boolean predictBasketGrip(final WalkStatement stmt, final boolean previousState) {
    if (stmt instanceof HoldBasketStatement) {
      return _predictBasketGrip((HoldBasketStatement)stmt, previousState);
    } else if (stmt instanceof Repeat) {
      return _predictBasketGrip((Repeat)stmt, previousState);
    } else if (stmt != null) {
      return _predictBasketGrip(stmt, previousState);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(stmt, previousState).toString());
    }
  }
}
